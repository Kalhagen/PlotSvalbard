% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dist2land.R
\name{dist2land}
\alias{dist2land}
\title{Calculate the closest distance to land for given coordinates}
\usage{
dist2land(x, lon.col = "longitude", lat.col = "latitude",
  map.type = "arctic50", bind = TRUE, dist.col = "dist",
  geodesic_distances = FALSE, cores = parallel::detectCores() - 1)
}
\arguments{
\item{x}{Data.frame containing geographic coordinates as decimal degrees}

\item{lon.col}{The name of the longitude column in \code{x}.}

\item{lat.col}{The name of the latitude column in \code{x}.}

\item{map.type}{a character string specifying the map type which land boundaries should be used for the distance calculation. See the \code{\link[=basemap]{type}} argument for possible map types.}

\item{bind}{Logical indicating whether \code{x} should be returned with the distances (\code{TRUE}, default) or should the distances be returned as vector (\code{FALSE}).}

\item{dist.col}{The name of the distance column, if \code{bind = TRUE}. Defaults to "dist".}

\item{geodesic_distances}{Logical indicating whether \code{\link[geosphere]{dist2Line}} function should be used to calculate shortest distances using the WGS84 ellipsoid (\code{TRUE}) or whether the distances should be calculated from UTM coordinates (\code{FALSE}, default). Setting the argument to \code{TRUE} presumably leads to more exact distance estimations, but takes a much longer time to process than the UTM coordinate estimation.}

\item{cores}{Integer value defining how many cores should be used in the calculations. Parallelization speeds up the function (see \code{\link[parallel]{mclapply}}), but naturally eats up computer resources during the calculation. Set to 1 to remove parallelization.}
}
\value{
If \code{bind = TRUE}, returns a data frame with calculated distances to land. If \code{bind = FALSE} returns vector in the same order than coordinates specified in \code{x}. \strong{Distances are returned as kilometers}.
}
\description{
Calculates the closest distance to land within a \link[=basemap]{map type} for a given set of coordinates
}
\details{
If \code{geodesic_distances = FALSE}, the function uses the \code{\link[rgeos]{gDistance}} function to calculate closest distances between coordinates in \code{x} and a specified SpatialPolygonsDataframe object. The spatial object (map) can be specified using the \code{\link[=basemap]{map.type}} argument. If \code{geodesic_distances = TRUE}, the \code{\link[geosphere]{dist2Line}} is used to calculate similar distances assumming an elliptical Earth. The \code{\link[geosphere]{dist2Line}} function is presumably more exact, especially for pan-Arctic maps, but considerably slower.
}
\examples{
## Distances from land using UTM coordinates
library(ggplot2)
data("npi_stations")

dists <- dist2land(npi_stations, lon.col = "Lon", lat.col = "Lat", map.type = "svalbard")
dists$Area <- ordered(dists$Area, c("Kongsfjorden", "Framstrait", "Rijpfjorden"))

ggplot(dists, aes(x = Area, y = dist, label = Station)) +
  geom_text() + ylab("Distance to land (km)")

## Geodesic distances are presumably more exact,
## but much slower to calculate. Do not use detailed
## maps for these:

d_utm <- dist2land(npi_stations, lon.col = "Lon", lat.col = "Lat",
  map.type = "barentssea", dist.col = "d_utm")
d_geo <- dist2land(npi_stations, lon.col = "Lon", lat.col = "Lat", map.type = "barentssea",
  geodesic_distances = TRUE, dist.col = "d_geo")

y <- merge(d_utm[c("Station", "d_utm")], d_geo[c("Station", "d_geo")])

ggplot(y, aes(x = d_utm, y = d_geo, label = Station)) +
 geom_text(color = "red") +
 geom_abline(slope=1, intercept=0) +
 scale_x_log10() + scale_y_log10()

## The processing difference between geodesic and UTM distances:

system.time(dist2land(npi_stations, lon.col = "Lon", lat.col = "Lat",
 map.type = "barentssea"))
#> user  system elapsed
#> 0.22    0.01    0.25

system.time(dist2land(npi_stations, lon.col = "Lon", lat.col = "Lat",
 map.type = "barentssea", geodesic_distances = TRUE))
#> user  system elapsed
#> 32.04    0.39   32.97

## Despite the inaccuracy due to polar stereographic protection
## the UTM version seems to produce feasible distances from land
## on pan-Arctic scale

data("meiofauna")
d_panarctic <- dist2land(meiofauna,  lon.col = "Lon", lat.col = "Lat", map.type = "arctic50")
d_panarctic <- transform_coord(d_panarctic, lon = "Lon", lat = "Lat", map.type = "arctic50",
bind = TRUE)

basemap("arctic50") +
 geom_point(data = d_panarctic, aes(x = lon.utm, y = lat.utm, color = dist), size = 3) +
 scale_color_viridis_c(name = "Distance (km)")

}
\author{
Mikko Vihtakari
}
